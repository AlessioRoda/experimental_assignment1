# Cluedo simulation for the Experimental Robotics Lab course, Alessio Roda S4458313

The purpose of this repository is to generate a simulation for the Cluedo game, in which the robot moves from a room to another in the Gazebo simulation, searches for ArUco markers that provide the hints to determine who is the murder and tries to provide a solution basing on the collected hints, untill the correct solution is found. The scenario in which the robot moves is composed by six different rooms in which there are five ArUco markers; the robot is able to move in the environment mapping it with the laser_scan that is mounted on its basis in order to generate a global map of the area. Also the robot has a manipulator in which is mounted a camera on the end effector that is needed to detect the markers: the robot continously moves the arm in order to visualize all the markers in the room, since they are in not defined position and orientations.


## Description of the architecture

![cluedo](https://user-images.githubusercontent.com/48511957/142238407-b648df07-2806-474c-a22e-d787d1638970.jpg)

The architecture is divided into four packages:
* aruco_ros: the package already provided to recognize the ArUco markers from the camera images
* erl2: the main package of the architecture: it provides the FSM that manages the behaviour of the robot, the node to interface with the ARMOR ontology and the node to perform the movement of the robotic arm needed to detect the markers
* exp_assignment3: package already porvided for the simulation
* moveit_config: the package generated with the Moveit setup assistant for generating all the packages that allow to control the motion of the arm

Concerning the aruco_ros and moveit_config packages only small modifications have beed done: for the first one a publisher of the marker ID has been added inside aruco_ros/aruco_ros/marker_publish.cpp, instad in the second one some small changes were neeeded to change the default Gazebo simulation environmet, generated by the setup assistant, to the new simulation environment provided for the Cluedo game.

Inside the erl2 folder you can find:
* config folder containing the configuration files for the Rviz simulation and the motor controllers
* launch folder in which there are the launch files for runnig all the nodes of the simulation
* msg folder containig the ErlOracle.msg for defining the hint message generated by the final_oracle node in the exp_assignemtn3 folder
* param folder containing all the parameters required for the SLAM gmapping
* spripts folder containig the ontology_interface.py script to manage the queries for the ARMOR ontology and the state_machine.py script to manage the SMACH state machine that represents the behaviour of the robot during the simualtion. It als contains a sub folder with the MyArmor and Place classes.
* src folder with the movearm.cpp file that porvides the node that manages the motion of the robotic arm
* srv folder with all the service custom messages
* urdf folder with the robot.urdf description file for the simulation
* world folder containing the world description of the simulation
* cluedo_ontology.owl that describes the initial ontology
* launch_simulation.sh for launching all the launch files simulatneously

The exp_assignment3 package has't been modified 

### Component diagram
![UML_diagram](https://user-images.githubusercontent.com/48511957/191712935-781f0542-6f30-49ae-a2de-c6724364a7f7.png)

Here is provideded the component diagram to better expalin how the architecture works. As it's possible to notice, the state_machine node is the "heart" of the entire architecture, in particular:
* It initializes Place objects to define the rooms (name, x, y) 
* Manages the motion of the robot by sending a MoveBase action goal with the coordinates of the room to reach when the simulation is in the MOVE state
* Receives all the maker ids that are detected by the aruco_ros node via /marker_id service, it saves and send them to the final oracle node, so to receive as a response the cluedo hint
* During the CHECK_CONSISTENCY state it sends the hints to the ontology_interface via /ontology_inteface/add_hint service 
* Asks for updating the ontology via /ontology_interface/update_request service
* Asks all the complete and consistent hypothesis in the ontology sending the /ontology_interface/check_consistency service and receives as service Response the list containing the IDs of all the complete and consistent hypothesis
* It asks the cluedo solution ID to the final_oracle node by sending the /oracle_solution request and compares the service response that receives with all the complete and consistent IDs that have received before. If one of them is the solution of the cluedo game, the simulation ends, otherwhise it continues

The ontology_interface node receives the previously described services to interact with the ARMOR ROS service to manage the ontology, in particular:
* It initializes the ontology by adding all the places, weapons and people of the game
* When the /ontology_interface/add_hint reques is receive, it stores the hints in three different lists 
* When /ontology_interface/update_request service request is received it adds the hints to the ontology and uodate it with the REASON armor command
* When /ontology_interface/check_consistency service request is rereceived it uses the armor commands to query all the complete and consistent hypothesis IDs of the ontology and returns them as service response 
* When /ontology_interface/ask_solution service request is received, it uses armor commands to query the perso, the wapon and the place of the cluedo game given the solution ID provides in the request

All the armor operations are performed by calling the MyArmor class, a custom class that provides a morea agile way to send armor messages (for more informations about, please have alook at the sphinx documentation)

The moevearm ros node does't comunicate with the rest of the architecture, it just moves the robotic arm in four different positions already defined with the moveit_setup_assistant. It allows the arm to continously move in an infinite loop, that allows to better investigate the environment in order to detect the markers

Finally, regarding the aruco_ros component and the final_oracle node everything was already porvided, except for the publisher to the /marker_id topic that allows the aruco_ros component to send the ID corresponding to the aruco marker that has been detected by the camera.

Here you can find also the rqt_graph generated by ROS to have another nuce representation about how the different nodes comunicate between eachothers.
![rosgraph](https://user-images.githubusercontent.com/48511957/191740042-d38bdb64-4807-4aa2-87bf-9d1e83e048de.png)







